<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Servo tutorial</title>
        <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
            rel="stylesheet"
            integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65"
            crossorigin="anonymous"
        />
    </head>
    <body>
        <div
            class="d-flex flex-column justify-content-center align-items-center vh-100 vw-100"
        >
            <div class="w-25 d-flex justify-content-around">
                <button class="btn btn-success" id="connectBtn">Connect</button>
                <button class="btn btn-danger" id="disconnectBtn">
                    Disconnect
                </button>
            </div>

            <button class="btn btn-primary mt-5" id="executeCmd">
                Execute command
            </button>
            <div>
                <p>Sent data:</p>
                <p id="sent-data-p"></p>
            </div>
            <div>
                <p>Received data:</p>
                <p id="received-data-p"></p>
            </div>
        </div>

        <script
            src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
            crossorigin="anonymous"
        ></script>
        <script>
            const connectBtn = document.getElementById("connectBtn");
            const disconnectBtn = document.getElementById("disconnectBtn");
            const executeCmd = document.getElementById("executeCmd");
            const sentDataPelem = document.getElementById("sent-data-p");
            const receivedDataPelem =
                document.getElementById("received-data-p");

            let serialPort;
            let serialPortReader;

            connectBtn.addEventListener("click", async () => {
                navigator.serial.requestPort().then(async (port) => {
                    serialPort = port;
                    await serialPort.open({ baudRate: 230400 });
                    alert("Connected!");
                    ReadFromSerialPortUntilClosed();
                });
            });

            disconnectBtn.addEventListener("click", () => {
                if (serialPortReader) {
                    serialPortReader.cancel();
                } else {
                    alert("Connect to the serial port first!");
                }
            });

            async function ReadFromSerialPortUntilClosed() {
                while (serialPort?.readable) {
                    serialPortReader = serialPort.readable.getReader();
                    try {
                        while (true) {
                            const { value, done } =
                                await serialPortReader.read();
                            if (done) {
                                break;
                            }

                            let leadingComma = "";
                            if (receivedDataPelem.innerHTML.length != 0) {
                                leadingComma = ",";
                            }

                            const hexStrResponse = Uint8ArrayToString(value);
                            receivedDataPelem.innerHTML = hexStrResponse;
                            console.log("Received: ", value);

                            let base = "Response CRC32 is ";
                            let validStr = "invalid";
                            if (IsCrc32Valid(value)) {
                                validStr = "valid";
                            }
                            receivedDataPelem.innerHTML +=
                                "<br/>" + base + " " + validStr;
                        }
                    } catch (error) {
                        console.log(error);
                    } finally {
                        serialPortReader.releaseLock();
                        await serialPort.close();
                        serialPort = null;
                        serialPortReader = null;
                        alert("Serial port is now closed.");
                    }
                }
            }

            executeCmd.addEventListener("click", SendDataToSerialPort);

            async function SendDataToSerialPort() {
                if (!serialPort) {
                    alert("Connect to the serial port first!");
                    return;
                }

                receivedDataPelem.innerHTML = "";
                sentDataPelem.innerHTML = "";

                // Define all the parameters for this command
                const alias = 255;
                const motor_command = 0;

                //size(1) + alias(1) + command_id(1) + CRC32(4)
                const motor_command_length = 7;

                const transmit_size = (motor_command_length << 1) | 1;

                let packet = new Uint8Array([
                    transmit_size,
                    alias,
                    motor_command,
                ]);

                const crcVal = crc32(packet);
                const crcArr = NumberToUint8Arr(crcVal, 4);

                packet = new Uint8Array([...packet, ...crcArr]);

                const hexStrPacket = Uint8ArrayToString(packet);
                sentDataPelem.innerHTML = hexStrPacket;

                console.log("Sending the following bytes: ", packet);
                const writer = serialPort.writable.getWriter();
                await writer.write(packet);
                writer.releaseLock();
                console.log("Data sent!");
            }

            function makeCRCTable() {
                let c;
                let crcTable = [];
                for (let n = 0; n < 256; n++) {
                    c = n;
                    for (let k = 0; k < 8; k++) {
                        c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
                    }
                    crcTable[n] = c;
                }
                return crcTable;
            }

            const crcTable = makeCRCTable();

            function crc32(data) {
                let crc = 0 ^ -1;
                for (let i = 0; i < data.length; i++) {
                    crc = (crc >>> 8) ^ crcTable[(crc ^ data[i]) & 0xff];
                }
                return crc ^ -1;
            }

            function NumberToUint8Arr(num, size, littleEndian = true) {
                let rawArrBuffer = new ArrayBuffer(size);
                if (size == 6) {
                    /**Extend the array buffer so that bigint fits */
                    rawArrBuffer = new ArrayBuffer(8);
                }
                const view = new DataView(rawArrBuffer);

                switch (size) {
                    case 1:
                        view.setUint8(0, Number(num));
                        break;
                    case 2:
                        view.setUint16(0, Number(num), littleEndian);
                        break;
                    case 4:
                        view.setUint32(0, Number(num), littleEndian);
                        break;
                    case 6:
                        view.setBigUint64(0, BigInt(num), littleEndian);
                        break;
                    case 8:
                        view.setBigUint64(0, BigInt(num), littleEndian);
                        break;
                    default:
                        throw `Unsupported byte size when converting ${num} to Uint8Arr: byte size received ${size}`;
                }

                let rawCurrent = new Uint8Array(size);

                for (let i = 0; i < size; i++) {
                    rawCurrent.set([view.getUint8(i)], i);
                }

                return rawCurrent;
            }

            //Input: Uint8Array e.g. [0xFF,0xA0,0]
            //Output: hexString e.g. "FFA000"
            /**
             * Returns a Uint8Array representing the bytes from the hex string
             * @param Input: Uint8Array e.g. [0xFF,0xA0,0]
             * @param Output: hex string e.g. "FFA000"
             */
            function Uint8ArrayToString(data) {
                if (data == null) {
                    return "";
                }

                let hexString = "";
                for (let i = 0; i < data.length; i++) {
                    let prefix = "";
                    let postfix = "";
                    if (data[i] <= 0xf) prefix = "0";
                    else prefix = "";

                    hexString += prefix + data[i].toString(16) + postfix;
                }
                return hexString.toUpperCase();
            }

            function IsCrc32Valid(response) {
                if (response.length < 6) {
                    /** We are expecting atleast 6 bytes because: size(1)+alias(1)+CRC32(4) = 6 bytes minimum length */
                    throw "CRC32 can not be calculated because the packet is not at least 6 bytes";
                }

                const crcVal = crc32(response.slice(0, response.length - 4));
                const crcArr = NumberToUint8Arr(crcVal, 4);

                const crcHexStr = Uint8ArrayToString(crcArr);
                const receivedCrcHexStr = response.slice(
                    response.length - 4,
                    response.length
                );
                return crcHexStr == Uint8ArrayToString(receivedCrcHexStr);
            }
        </script>
    </body>
</html>
