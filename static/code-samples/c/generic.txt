#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef _WIN32
#include<windows.h>
const char* serialPortName = "\\\\.\\COM5";
#else
// MAC or Linux
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
const char* serialPortName = "/dev/ttyUSB0";
#endif

uint32_t crcTable[256] = { 0 };
void SetupSerialPort();
FILE* OpenPort(const char* serialPort);
uint32_t ConvertDoubleToUint32LittleEndian(const double input);
void ConvertUintTo4BytesArr(uint8_t* buffer, uint8_t buffSize, uint32_t number);
uint32_t crc32(uint8_t* data, size_t length);
void makeCRCTable();
uint32_t ConvertUint32ToLittleEndian(uint32_t input);

int main(int argc, char* argv[])
{
	makeCRCTable();

	SetupSerialPort();
	FILE* portHandle = OpenPort(serialPortName);

	if (!portHandle)
		return -1;

	// Define all the parameters for this command
	uint8_t alias = 255;
	uint8_t motor_command = 0;
	uint8_t motor_command_length = 7;
	uint8_t transmit_size = (motor_command_length << 1) | 1;

	const uint8_t initialPartSize = 3;
	uint8_t* cmd = malloc(initialPartSize);
	if (cmd == NULL)
	{
		printf("\nCould not allocate memory for cmd.\n");
		return -1;
	}
	cmd[0] = transmit_size;
	cmd[1] = alias;
	cmd[2] = motor_command;

	uint32_t crcVal = crc32(cmd, initialPartSize);

	uint8_t crcArr[4] = { 0 };
	ConvertUintTo4BytesArr(crcArr, 4, ConvertUint32ToLittleEndian(crcVal));

	uint8_t* cmd_transmit = malloc(motor_command_length);
	if (cmd_transmit == NULL)
	{
		printf("\nCould not allocate memory for cmd_transmit.\n");
		return -1;
	}

	memcpy(cmd_transmit, cmd, initialPartSize);
	memcpy(cmd_transmit + initialPartSize, crcArr, 4);

	memset(cmd, 0, initialPartSize);
	free(cmd);
	cmd = NULL;

	printf("Sending the following command: \n");
	for (int i = 0; i < motor_command_length; i++)
	{
		printf("0x%x ", cmd_transmit[i]);
	}
	printf("\n");

	size_t writtenBytes = fwrite(cmd_transmit, sizeof(uint8_t), motor_command_length, portHandle);

	memset(cmd_transmit, 0, motor_command_length);
	free(cmd_transmit);
	cmd_transmit = NULL;

	fflush(portHandle);
	printf("Wrote %zd bytes.\n", writtenBytes);

	const size_t recvSize = 6;//size(1) + crc_enabled(1) + crc32(4)

	if (alias == 255)
	{
		printf("No response is expected.\n");
	}
	else
	{
		uint8_t* recv_buffer = (uint8_t*)malloc(recvSize);

		if (recv_buffer == NULL)
		{
			printf("Could not allocate memory for the receive buffer.\n");
			fclose(portHandle);
			return -1;
		}

		memset(recv_buffer, 0, recvSize);

		size_t readBytes = fread(recv_buffer, sizeof(uint8_t),
			recvSize, portHandle);

		if (readBytes != recvSize)
		{
			//do not return as we still need to clean up
			printf("Command timed out or the response had a wrong size.\n");
		}

		printf("Received: ");
		for (int i = 0; i < recvSize; i++)
		{
			printf("0x%x ", recv_buffer[i]);
		}
		printf("\n");

		memset(recv_buffer, 0, recvSize);
		free(recv_buffer);
		recv_buffer = NULL;
	}

	printf("\n\n");

	fclose(portHandle);

	return 0;
}

FILE* OpenPort(const char* serialPort)
{
	FILE* portHandle = fopen(serialPort, "rb+");

	if (portHandle == NULL)
	{
		printf("Cannot open COM port.\n");
	}
	else
	{
		// Make sure there is no data waiting to be flushed after opening
		fflush(portHandle);
	}

	return portHandle;
}

/* This method will assure the port is in a valid state to be opened using the generic fopen
   Each OS has different APIs to set the serial port settings */
void SetupSerialPort()
{
#ifdef WIN32

	HANDLE hComm = CreateFile(serialPortName,
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		0,
		NULL);

	if (hComm == INVALID_HANDLE_VALUE)
	{
		printf("Port %s is invalid, also make sure you set the read/write access writes.\n", serialPortName);
		return;
	}

	//abort any read/writes and clear the input/output buffers
	PurgeComm(hComm, PURGE_RXABORT | PURGE_RXCLEAR | PURGE_TXABORT | PURGE_TXCLEAR);

	DCB dcbSerialParams;
	SecureZeroMemory(&dcbSerialParams, sizeof(DCB));
	dcbSerialParams.DCBlength = sizeof(DCB);

	dcbSerialParams.fBinary = TRUE;
	dcbSerialParams.XoffLim = 0x4000;
	dcbSerialParams.XonChar = 0x11;
	dcbSerialParams.XoffChar = 0x13;

	dcbSerialParams.BaudRate = 230400;
	dcbSerialParams.ByteSize = 8;
	dcbSerialParams.StopBits = ONESTOPBIT;
	dcbSerialParams.Parity = NOPARITY;
	BOOL Status = SetCommState(hComm, &dcbSerialParams);
	if (Status == FALSE)
	{
		printf("Cannot setup port %s.\n", serialPortName);
		CloseHandle(hComm);
		return;
	}

	COMMTIMEOUTS timeouts;
	SecureZeroMemory(&timeouts, sizeof(COMMTIMEOUTS));
	GetCommTimeouts(hComm, &timeouts);

	timeouts.ReadIntervalTimeout = MAXDWORD;
	timeouts.ReadTotalTimeoutMultiplier = MAXDWORD;
	//read timeout to 2 seconds
	timeouts.ReadTotalTimeoutConstant = 2000;
	timeouts.WriteTotalTimeoutMultiplier = 0;
	timeouts.WriteTotalTimeoutConstant = 0;

	if (!SetCommTimeouts(hComm, &timeouts))
		printf("Error timeouts.\n");

	Sleep(500);
	SecureZeroMemory(&dcbSerialParams, sizeof(DCB));
	dcbSerialParams.DCBlength = sizeof(DCB);

	GetCommState(hComm, &dcbSerialParams);
	printf("Baudrate: %d\nStopBits: %d\nParity: %d\nByteSize: %d\n\n",
		dcbSerialParams.BaudRate,
		dcbSerialParams.StopBits,
		dcbSerialParams.Parity,
		dcbSerialParams.ByteSize);

	CloseHandle(hComm);

#else

	/* Open and configure the serial port using posix calls */
	int fd = open(serialPortName, O_RDWR | O_NOCTTY);
	if (fd < 0)
	{
		printf("Port %s is invalid, also make sure you set the read/write access writes.\n", serialPortName);
		return;
	}

	struct termios options; /* Serial port settings */
	memset(&options, 0, sizeof(struct termios));

	/* Set up serial port
	baudRate: 230400
	StopBits: 1
	Parity: None
	DataBits 8 */
	options.c_cflag = 6323;
	options.c_iflag = IGNBRK;
	options.c_oflag = 0;
	options.c_lflag = 0;

	/* Apply the settings */
	tcflush(fd, TCIOFLUSH);//discard any input/output that may sit in the buffer
	cfmakeraw(&options);
	tcsetattr(fd, TCSANOW, &options);
	usleep(500 * 1000);

	close(fd);
#endif

}

static const uint32_t bmask32[4] = { 0x0FF, 0xFF00, 0xFF0000, 0xFF000000 };
static const uint64_t bmask64[8] = { 0xFF, 0xFF00, 0xFF0000, 0xFF000000, 0xFF00000000, 0xFF0000000000, 0xFF000000000000, 0xFF00000000000000 };

uint32_t ConvertDoubleToUint32LittleEndian(const double input)
{
	uint32_t result = 0;

	if (input < 0)
	{
		if (input < INT32_MIN)
		{
			return 0;
		}

		int32_t input_s = (int32_t)input;
		result |= (input_s & bmask32[0]) << 24;
		result |= (input_s & bmask32[1]) << 8;
		result |= (input_s & bmask32[2]) >> 8;
		result |= (input_s & bmask32[3]) >> 24;
	}
	else
	{
		if (input > UINT32_MAX)
		{
			return 0;
		}

		result = ConvertUint32ToLittleEndian((uint32_t)input);
	}

	return result;
}

uint32_t ConvertUint32ToLittleEndian(uint32_t input)
{
	uint32_t result = 0;

	result |= (input & bmask32[0]) << 24;
	result |= (input & bmask32[1]) << 8;
	result |= (input & bmask32[2]) >> 8;
	result |= (input & bmask32[3]) >> 24;

	return result;
}

void ConvertUintTo4BytesArr(uint8_t* buffer, uint8_t buffSize, uint32_t number)
{
	if (buffSize != sizeof(uint32_t))
	{
		//assure the buffer size is 4 bytes
		return;
	}

	for (int i = buffSize - 1, j = 0; i >= 0; i--, j++)
	{
		buffer[j] = (number & bmask32[i]) >> (i * 8);
	}
}

void makeCRCTable()
{
	uint32_t c = 0;

	for (uint32_t n = 0; n < 256; n++) {
		c = n;
		for (uint32_t k = 0; k < 8; k++) {
			c = ((c & 1) ? (0xEDB88320 ^ (c >> 1)) : (c >> 1));
		}
		crcTable[n] = c;
	}
}

uint32_t crc32(uint8_t* data, size_t length)
{
	uint32_t crc = 0 ^ -1;
	for (int i = 0; i < length; i++) {
		crc = (crc >> 8) ^ crcTable[(crc ^ data[i]) & 0xFF];
	}
	return crc ^ -1;
};